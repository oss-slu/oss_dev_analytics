<html>

<head>
  <title> Metrics Dashboard </title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Georgia, 'Times New Roman', Times, serif;
      margin: 0;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    h1{
      background-color: #550C18;
      color: white;
      padding: 20px;
      border-radius: 8px;
    }
    h2{
      color: #550C18;
      margin-top: 0;
    }
    .sidebar {
      width: 150px;
      background-color: #550C18;
      color: #ffffff;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 1rem;
      flex-shrink: 0;
    }

    .sidebar h2 {
      color: #ffffff;
      text-align: center;
      margin-bottom: 1.5rem;
    }

    .sidebar button {
      width: 90%;
      background: none;
      border: none;
      color: #ffffff;
      text-align: center;
      padding: 0.7rem 0.2rem;
      margin: 0.2rem 0;
      cursor: pointer;
      border-radius: 6px;
      font-size: 0.9rem;
    }

    .sidebar button:hover,
    .sidebar button.active {
      background-color: #2e1010;
    }

    .content {
      flex-grow: 1;
      padding: 1.5rem 2rem;
      overflow-y: auto;
      background: #e2e8dd;
      
    }


    #team .chart-container {
      width: 100%;
      max-width: 1000px;
      margin-left: auto;
      margin-right: auto;
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
      height: 400px;
    }
    #timeBasedMetrics, #volumeBasedMetrics {
      flex: 1 1 45%;
      min-width: 300px;
      height: auto;
      width: auto;
    }

    #metrics .chart-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        max-width: 1000px;
        margin-left: auto;
        margin-right: auto;
      
    }
    

    #metrics .chart-grid canvas {
        width: 100%;
        max-height: 250px; 
        max-height: 250px;
    }

    select {
      margin: 0.5rem;
      padding: 0.4rem;
    }

    #metricsDisplay {
      margin-top: 1rem;
      padding: 1rem;
      border: 1px solid #ddd;
      border-radius: 6px;
      background: #f9f9f9;

    }

    #metricsDisplay ul {
      list-style: none;
      padding: 0;

    }

    #metricsDisplay li {
      margin: 0.4rem 0;

    }
  </style>
</head>

<body>

  <div class="sidebar">
    <h2>Dashboard</h2>
    <button class="tab-button active" data-tab="home">Home</button>
    <button class="tab-button" data-tab="team">Team</button>
    <button class="tab-button" data-tab="metrics">Metrics</button>
  </div>

  <div class="content">
    <div id="home" class="tab-content" style="display: block;">
      <h1>Home</h1>
      <p>Add to later.</p>
    </div>

    <div id="team" class="tab-content" style="display: none;">
      <h1>Team Metrics</h1>
      <h2>Select User & Sprint</h2>
      <label for="teamUserSelect">User:</label>
      <select id="teamUserSelect">
        <option value="tm" selected>Overall Team</option>
        <option value="tl">Team Lead</option>
        <option value="dev-1">Developer 1</option>
        <option value="dev-2">Developer 2</option>
      </select>

      <label for="teamSprintSelect">Sprint:</label> 
      <select id="teamSprintSelect"> 
        <option value="0">Sprint 1</option>
        <option value="1">Sprint 2</option>
        <option value="2">Sprint 3</option>
        <option value="3">Sprint 4</option>
        <option value="4">Sprint 5</option>
        <option value="5">Sprint 6</option>
      </select>
      <div class="chart-container">
        <canvas id="timeBasedMetrics"></canvas>
        <canvas id="volumeBasedMetrics"></canvas>
      </div>
      <div id="metricsDisplay"></div>
    </div>

    <div id="metrics" class="tab-content" style="display: none;">
      <h1>Manual Metrics</h1>
      <h2>Select User & Sprint</h2>
      <label for="metricsUserSelect">User:</label>
      <select id="metricsUserSelect">
        <option value="tm">Team</option>
        <option value="tl">Team Lead</option>
        <option value="dev-1">Developer 1</option>
        <option value="dev-2">Developer 2</option>
      </select>

      <label for="metricsSprintSelect">Sprint:</label>
      <select id="metricsSprintSelect">
        <option value="0">Sprint 1</option>
        <option value="1">Sprint 2</option>
        <option value="2">Sprint 3</option>
        <option value="3">Sprint 4</option>
        <option value="4">Sprint 5</option>
        <option value="5">Sprint 6</option>
      </select>
      <div class="chart-grid">
        <canvas id="clientSatisfaction"></canvas>
        <canvas id="teamSatisfaction"></canvas>
        <canvas id="collaboration"></canvas>
        <canvas id="sprintConfidence"></canvas>
        <canvas id="goalAchievement"></canvas>
      </div>
    </div>
  </div>

  <script>
    const buttons = document.querySelectorAll(".tab-button");
    const tabs = document.querySelectorAll(".tab-content");

    buttons.forEach((btn) => {
      btn.addEventListener("click", () => {
        buttons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");

        tabs.forEach((tab) => (tab.style.display = "none"));
        document.getElementById(btn.dataset.tab).style.display = "block";
      });
    });

    function createManualChart(id, chartLabels, datasetLabels, dataValues, color) {
      new Chart(document.getElementById(id), {
        type: 'bar',
        data: {
          labels: chartLabels,
          datasets: [{
            label: datasetLabels,
            data: dataValues,
            backgroundColor: color
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: {
                display: true,
                text: 'Sprints'
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Rating'
              }
            }
          }
        }
      });
    }

    fetch('manual_metrics.csv')
      .then(response => response.text())
      .then(csv => {
        const rows = csv.trim().split("\n").slice(1);
        const metrics = {
          "client satisfaction": [],
          "team satisfaction": [],
          "collaboration": [],
          "sprint confidence": [],
          "goal achievement": []
        };

        const labels = ["Sprint 1", "Sprint 2", "Sprint 3", "Sprint 4", "Sprint 5", "Sprint 6"];
        rows.forEach(row => {
          cols = row.split(",");
          if (cols[1] == "client satisfaction") {
            metrics["client satisfaction"].push(parseFloat(cols[2]))
          } else if (cols[1] == "team satisfaction") {
            metrics["team satisfaction"].push(parseFloat(cols[2]))
          } else if (cols[1] == "collaboration") {
            metrics["collaboration"].push(parseFloat(cols[2]))
          } else if (cols[1] == "sprint confidence") {
            metrics["sprint confidence"].push(parseFloat(cols[2]))
          } else {
            metrics["goal achievement"].push(parseFloat(cols[2]))
          }
        })

        createManualChart("clientSatisfaction", labels, "Client Satisfaction", metrics["client satisfaction"], "mediumorchid");
        createManualChart("teamSatisfaction", labels, "Team Satisfaction", metrics["team satisfaction"], "lightskyblue");
        createManualChart("collaboration", labels, "Collaboration", metrics["collaboration"], "lightgreen");
        createManualChart("sprintConfidence", labels, "Sprint Confidence", metrics["sprint confidence"], "lightpink");
        createManualChart("goalAchievement", labels, "Goal Achievement", metrics["goal achievement"], "moccasin");
      })

    let metricsData = {};
    let timeChartInstance = null;
    let volumeChartInstance = null;

    const metricDescriptions = {
      leadTime: "Time from task creation to completion.",
      cycleTime: "Time from when the task was started to task completion.",
      deliveryMetrics: "Time from code commit to deployment.",
      commitFrequency: "Number of commits made during the sprint.",
      issuesOpened: "Number of issues open during the sprint.",
      issuesClosed: "Number of issues resolved during the sprint.",
      issueTimeResolved: "Average time taken to resolve issues.",
      prTimeMerged: "Average time from pull request creation to merge.",
      wip: "Number of work items currently in progress.",
      velocity: "Number of commits per sprint.",
      defectRate: "Proportion of closed issues with bugs.",
      blockedIssues: "Number of issues that were blocked during the sprint."
    };

    function updateMetricsDisplay() {
      const user = document.getElementById("teamUserSelect").value;
      

      const sprintIndex = parseInt(document.getElementById("teamSprintSelect").value); 
      
      const display = document.getElementById("metricsDisplay");

      if (user == 'team') {
        display.innerHTML = "<h3>Please select an individual user to view metrics.</h3>";
        return;
      }
      
      const sprintDates = [
        "Sep 8 - Sep 22", "Sep 22 - Oct 6", "Oct 6 - Oct 20",
        "Oct 20 - Nov 3", "Nov 3 - Nov 17", "Nov 17 - Nov 31"
      ];


      const selectedUserText = document.getElementById("teamUserSelect").options[document.getElementById("teamUserSelect").selectedIndex].text;
      
      const orgName = metricsData.org || "unknownOrg";
      const repoName = metricsData.repo || "unknownRepo";
      let html = `<h3>Metrics for ${selectedUserText} - Sprint ${sprintIndex + 1} (${sprintDates[sprintIndex]}) | Repo: ${repoName} | Org: ${orgName}</h3><ul>`;

      const autoMetrics = [
        "leadTime", "cycleTime", "deliveryMetrics",
        "commitFrequency", "issuesOpened", "issuesClosed",
        "issueTimeResolved", "prTimeMerged", "wip"
      ];

      autoMetrics.forEach(key => {
        const metricKey =
          user === "tl" ? `${key}-tl` :
          user === "dev-1" ? `${key}-1` : `${key}-2`;

        const value = metricsData[metricKey]?.[sprintIndex];

        if (value === undefined) {
          html += `<li><strong>${key}:</strong> N/A</li>`;
          return;
        }

        const teamKeys = [`${key}-tl`, `${key}-1`, `${key}-2`];
        let teamTotal = 0;
        teamKeys.forEach(k => {
          if (metricsData[k]?.[sprintIndex] !== undefined) {
            teamTotal += metricsData[k][sprintIndex];
          }
        });

        let pct = teamTotal > 0 ? (value / teamTotal) * 100 : 0;

        const description = metricDescriptions[key] || "No description available.";

        const userColor = "#eabda8";
        const teamColor = "#cccccc";

        html += `
          <li>
            <strong title="${description}" style="cursor: help;">${key}:</strong> ${value}
            <div style="width: 100%; max-width: 300px; height: 15px; border-radius: 8px; overflow: hidden; display: flex; margin-top: 5px;">
              <div style="width: ${pct}%; background-color: ${userColor};"></div>
              <div style="width: ${100 - pct}%; background-color: ${teamColor};"></div>
            </div>
            <small>${pct.toFixed(1)}% of team total</small>
          </li>
        `;

      });

      html += "</ul>";
      display.innerHTML = html;
    }
    

    function createOrUpdateTimeChart(chartLabels, datasetLabels, dataValues) {
      if (timeChartInstance) {
        timeChartInstance.destroy();
      }
      const ctx = document.getElementById("timeBasedMetrics").getContext("2d");
      timeChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: chartLabels,
          datasets: [{
            label: datasetLabels,
            data: dataValues,
            backgroundColor: 'rgba(85, 12, 24, 0.7)',
            borderColor: 'rgba(85, 12, 24, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: {
                display: true,
                text: 'Time-Based Metrics'
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Time (Days)'
              }
            }
          },
          plugins: {
            legend: {
              display: true
            },
              tooltip: {
                callbacks: {
                label: function(context) {
                  const timeMetricKeyMap = {
                    "Lead Time": "leadTime",
                    "Cycle Time": "cycleTime",
                    "Delivery Metrics": "deliveryMetrics",
                    "Issue Time Resolved": "issueTimeResolved",
                    "PR Time Merged": "prTimeMerged"
                  };
                  const label = context.label;
                  const key = timeMetricKeyMap[label];
                  return metricDescriptions[key] || 'No description';
              }
              }
            }
          }
        }
      });
    }
    function createOrUpdateVolumeChart(chartLabels, datasetLabels, dataValues) {
      if (volumeChartInstance) {
        volumeChartInstance.destroy();
      }
      const ctx = document.getElemeantById("volumeBasedMetrics").getContext("2d");
      volumeChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: chartLabels,
          datasets: [{
            label: datasetLabels,
            data: dataValues,
            backgroundColor: 'rgba(85, 12, 24, 0.7)',
            borderColor: 'rgba(85, 12, 24, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: {
                display: true,
                text: 'Volume-Based Metrics'
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Count'
              }
            }
          },
          plugins: {
            legend: {
              display: true
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const volumeMetricKeyMap = {
                    "Delivery Metrics": "deliveryMetrics",
                    "Commit Frequency": "commitFrequency",
                    "Issues Opened": "issuesOpened",
                    "Issues Closed": "issuesClosed",
                    "WIP": "wip"
                  };
                  const label = context.label;
                  const key = volumeMetricKeyMap[label];
                  return metricDescriptions[key] || 'No description';
                }
              }
            }
          }
        }
      });
    }

    function updateTeamTab() {
      updateMetricsDisplay();

      const user = document.getElementById("teamUserSelect").value;
      const sprintIndex = parseInt(document.getElementById("teamSprintSelect").value);
      const selectedUserText = document.getElementById("teamUserSelect").options[document.getElementById("teamUserSelect").selectedIndex].text;

      const timeBasedLabels = [
        "Lead Time", "Cycle Time", "Delivery Metrics",
        "Issue Time Resolved", "PR Time Merged"
      ];
      const metricKeys = [
        "leadTime", "cycleTime", "deliveryMetrics",
        "issueTimeResolved", "prTimeMerged"
      ];
      const volumeKeys = [
        "deliveryMetrics", "commitFrequency", "issuesOpened", "issuesClosed", "wip"
      ];
      const volumeBasedLabels = [
        "Delivery Metrics", "Commit Frequency", "Issues Opened", "Issues Closed", "WIP"
      ];
      let timeBasedData = [];
      let volumeBasedData = [];
      let chartLabel = '';

      if (user == 'tm') {

        chartLabel = `Overall Team Average - Sprint ${sprintIndex + 1}`; 
        const users = ['tl', '1', '2'];

        timeBasedData = metricKeys.map(key => {
          let total = 0;
          let count = 0;
          users.forEach(u_suffix => {
            const userKey = `${key}-${u_suffix}`;
            if (metricsData[userKey] && metricsData[userKey][sprintIndex] !== undefined) {
              total += metricsData[userKey][sprintIndex];
              count++;
            }
          });
          return count > 0 ? (total / count) : 0;

        });
              volumeBasedData = volumeKeys.map(key => {
        let total = 0;
        users.forEach(u_suffix => {
          const userKey = `${key}-${u_suffix}`;
          if (metricsData[userKey] && metricsData[userKey][sprintIndex] !== undefined) {
            total += metricsData[userKey][sprintIndex];
          }
        });
        return total;
      });
      } else {
        const dataSuffix = user === "tl" ? "tl" : (user === "dev-1") ? "1" : "2";
        chartLabel = `${selectedUserText} - Sprint ${sprintIndex + 1}`;
        timeBasedData = metricKeys.map(key => {
          const userKey = `${key}-${dataSuffix}`; 
          return metricsData[userKey]?.[sprintIndex] ?? 0;
        });
        volumeBasedData = volumeKeys.map(key => {
          const userKey = `${key}-${dataSuffix}`; 
          return metricsData[userKey]?.[sprintIndex] ?? 0;
        });
      }

      createOrUpdateTimeChart(timeBasedLabels, chartLabel, timeBasedData);
      createOrUpdateVolumeChart(volumeBasedLabels, chartLabel, volumeBasedData);
    }
    

    fetch("metrics.json")
      .then(response => response.json())
      .then(jsonData => {
        metricsData = jsonData;
        updateTeamTab();

        document.getElementById("teamUserSelect").addEventListener("change", updateTeamTab);
        document.getElementById("teamSprintSelect").addEventListener("change", updateTeamTab);
      });

  </script>
</body>

</html>