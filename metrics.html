<html>

<head>
    <title> Metrics Dashboard </title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      /* basic styling for body */
        body {
            font-family: Georgia, 'Times New Roman', Times, serif;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden; /* only main content scrolls */
        }

        /* page headers */

        h1 {
            background-color: #550C18;
            color: white;
            padding: 20px;
            border-radius: 8px;
        }

        h2 {
            color: #550C18;
            margin-top: 0;
        }

        /* sidebar nav styling */

        .sidebar {
            width: 150px;
            background-color: #550C18;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 1rem;
            flex-shrink: 0; /* keeps sidebar the same size */
        }

        .sidebar h2 {
            color: #ffffff;
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .sidebar button {
            width: 90%;
            background: none;
            border: none;
            color: #ffffff;
            text-align: center;
            padding: 0.7rem 0.2rem;
            margin: 0.2rem 0;
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .sidebar button:hover,
        .sidebar button.active {
            background-color: #2e1010;
        }
        /* main content styling */
        .content {
            flex-grow: 1; /* content takes up all available space */
            padding: 1.5rem 2rem;
            overflow-y: auto;
            background: #e2e8dd;
        }

        /* team tab chart styling */
        #team .chart-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            align-items: stretch;
            gap: 30px;
            width: 100%;
            height: calc(100vh - 250px); /* dynamic height calculation to ensure graphs look appropriately sized */
            margin-top: 20px;
        }

        /* team tab individual chart styling */
        #timeBasedMetrics,
        #volumeBasedMetrics {
            flex: 1 1 45%; /* sets flext-grow, flex-shrink and flex-basis, can both grow and shrink as needed and states ideal chart size */
            min-width: 350px;
            height: 100%;
        }

        /* manual metrics tab chart grid styling */
        #metrics .chart-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            gap: 20px;
            max-width: 1000px;
            margin-left: auto;
            margin-right: auto;
        }

        #metrics .chart-grid > div { /* for all of the metrics div elements set these stylings */
            width: 300px; /* ideal width of each chart */
            max-width: 100%;
            margin-bottom: 20px;
            text-align: center;
        }

        #metrics .chart-grid canvas { /* graph specific stylings */
            width: 100% !important;
            height: 250px !important;
        }

        select {
            margin: 0.5rem;
            padding: 0.4rem;
        }

        #metricsDisplay {
            margin-top: 1rem;
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #f9f9f9;
        }

        #metricsDisplay ul {
            list-style: none;
            padding: 0;
        }

        #metricsDisplay li {
            margin: 0.4rem 0;
        }

        .home-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 10px;
            border-bottom: 1px solid #ccc;
        }

        .home-controls input[type="text"] {
            padding: 0.4rem;
            font-size: 1rem;
            border-radius: 6px;
            border: 1px solid #ccc;
        }


        .home-controls button {
            background: #550C18;
            color: white;
            border: none;
            padding: 0.5rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 16px;
            margin-top: 15px;
            margin-bottom: 12px;
        }

        .summary-card {
            background: white;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 0 6px rgba(0,0,0,0.08);
        }

        .repo-activity {
            margin-top: 12px;
        }

        .repo-activity .progress { background: #eee; border-radius: 10px; height: 8px; margin: 5px 0; }
        .repo-activity .bar { background: #550C18; height: 8px; border-radius: 10px; }

        .home-two-col{ display: grid; grid-template-columns: 1fr 420px; gap: 18px; align-items: start; margin-bottom: 12px; }


        .contributors-table { width: 100%; border-collapse: collapse; }
        .contributors-table th, .contributors-table td { border-bottom: 1px solid #ddd; text-align: left; padding: 6px; }


        .home-charts { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; }


        @media (max-width: 900px) {
            .home-two-col { grid-template-columns: 1fr; }
            .home-charts { grid-template-columns: 1fr; }
        }
    </style>
</head>

<body>

    <div class="sidebar">
        <button class="tab-button active" data-tab="home">Home</button>
        <button class="tab-button" data-tab="team">Team</button>
        <button class="tab-button" data-tab="metrics">Metrics</button>
    </div>

    <div class="content">
        <div id="home" class="tab-content" style="display: block;">
            <div class="home-header">
                <div>
                    <h1>OSS-SLU Dashboard</h1>
                    <div style="margin-top:8px;">
                    </div>
                </div>
            </div>


            <div class="summary-grid" id="summaryGrid">
                <div class="summary-card"><p>Total Repos</p><h2 id="reposCount">-</h2></div>
                <div class="summary-card"><p>Total Commits</p><h2 id="commitsCount">-</h2></div>
                <div class="summary-card"><p>Avg Lead Time</p><h2 id="leadTimeHome">-</h2></div>
                <div class="summary-card"><p>Avg Cycle Time</p><h2 id="cycleTimeHome">-</h2></div>
                <div class="summary-card"><p>Total Contributors</p><h2 id="contributorsCount">-</h2></div>
            </div>


            <div class="home-two-col">
                <div class="summary-card">
                    <h3>Total Repos by Activity</h3>
                    <div id="repoActivity" class="repo-activity"></div>
                </div>


                <div class="summary-card">
                    <h3>Contributor Details</h3>
                    <table class="contributors-table" id="contributorsTableHome">
                        <thead>
                            <tr><th>Contributor</th><th>Commits</th><th>PRs</th><th>Issues</th></tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <div class="home-charts">
                <div class="summary-card"><h3>Delivery Velocity over time</h3><canvas id="velocityChartHome"></canvas></div>
                <div class="summary-card"><h3>Lead & Cycle Time over time</h3><canvas id="leadCycleChartHome"></canvas></div>
            </div>
        </div>

        <div id="team" class="tab-content" style="display: none;">
            <h1>Team Metrics</h1>
            <h2>Select Repository, User & Sprint</h2>

            <label for="teamRepoSelect">Repository:</label>
            <select id="teamRepoSelect">
                <option value="" disabled selected>Select Repository</option>
            </select>

            <label for="teamUserSelect">User:</label>
            <select id="teamUserSelect">
                <option value="" disabled selected>Select User</option>
            </select>

            <label for="teamSprintSelect">Sprint:</label>
            <select id="teamSprintSelect">
                <option value="0">Sprint 1</option>
                <option value="1">Sprint 2</option>
                <option value="2">Sprint 3</option>
                <option value="3">Sprint 4</option>
                <option value="4">Sprint 5</option>
                <option value="5">Sprint 6</option>
            </select>
            <div class="chart-container">
                <canvas id="timeBasedMetrics"></canvas>
                <canvas id="volumeBasedMetrics"></canvas>
            </div>
            <div id="metricsDisplay"></div>
        </div>

        <div id="metrics" class="tab-content" style="display: none;">
            <h1>Manual Metrics</h1>
            <h2>Select Repository, User & Sprint</h2>

            <!-- inserted repo + user dropdowns for metrics tab (repo first, user second, sprint third) -->
            <label for="metricsRepoSelect">Repository:</label>
            <select id="metricsRepoSelect">
                <option value="" disabled selected>Select Repository</option>
            </select>

            <label for="metricsUserSelect">User:</label>
            <select id="metricsUserSelect">
                <option value="tm" selected>Overall Team</option>
                <option value="tl">Team Lead</option>
                <option value="dev-1">Developer 1</option>
                <option value="dev-2">Developer 2</option>
            </select>

            <label for="metricsSprintSelect">Sprint:</label>
            <select id="metricsSprintSelect">
                <option value="0" selected>Sprint 1</option>
                <option value="1">Sprint 2</option>
                <option value="2">Sprint 3</option>
                <option value="3">Sprint 4</option>
                <option value="4">Sprint 5</option>
                <option value="5">Sprint 6</option>
            </select>
            <div class="chart-grid">
                <div>
                    <h3 id="clientSatisfactionTitle">Client Satisfaction</h3>
                    <canvas id="clientSatisfaction"></canvas>
                </div>
                <div>
                    <h3 id="teamSatisfactionTitle">Team Satisfaction</h3>
                    <canvas id="teamSatisfaction"></canvas>
                </div>
                <div>
                    <h3 id="collaborationTitle">Collaboration</h3>
                    <canvas id="collaboration"></canvas>
                </div>
                <div>
                    <h3 id="sprintConfidenceTitle">Sprint Confidence</h3>
                    <canvas id="sprintConfidence"></canvas>
                </div>
                <div>
                    <h3 id="goalAchievementTitle">Goal Achievement</h3>
                    <canvas id="goalAchievement"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>

      // all gloabal variables and event listeners

        // switch tabs on nav button click
        const buttons = document.querySelectorAll(".tab-button");
        const tabs = document.querySelectorAll(".tab-content");
        
        
        // store parsed manual metrics data from manual_metrics.csv
        let parsedManualMetricsData = {};
        // stores parsed data from metrics.json
        let metricsData = {};

        // store manual chart instances for updates
        let manualChartInstances = {};
        // check if time and volume chart instances exist for updates
        let timeChartInstance = null;
        let volumeChartInstance = null;

        // descriptions for metrics, shown in tooltips
        const metricDescriptions = {
            leadTime: "Time from task creation to completion.",
            cycleTime: "Time from when the task was started to task completion.",
            deliveryMetrics: "Time from code commit to deployment.",
            commitFrequency: "Number of commits made during the sprint.",
            issuesOpened: "Number of issues open during the sprint.",
            issuesClosed: "Number of issues resolved during the sprint.",
            issueTimeResolved: "Average time taken to resolve issues.",
            prTimeMerged: "Average time from pull request creation to merge.",
            wip: "Number of work items currently in progress.",
            velocity: "Number of commits per sprint.",
            defectRate: "Proportion of closed issues with bugs.",
            blockedIssues: "Number of issues that were blocked during the sprint."
        };

        // tab button event listeners
        buttons.forEach((btn) => {
            btn.addEventListener("click", () => {
                // set active button styling
                buttons.forEach((b) => b.classList.remove("active"));
                btn.classList.add("active");

                // show corresponding tab content
                const tabId = btn.dataset.tab;
                tabs.forEach((tab) => (tab.style.display = "none"));
                document.getElementById(tabId).style.display = "block";

                // on tab switch, resize charts or update manual charts
                if (tabId === "team") {
                    setTimeout(() => {
                        if (timeChartInstance) {
                            timeChartInstance.resize();
                        }
                        if (volumeChartInstance) {
                            volumeChartInstance.resize();
                        }
                    }, 0) // makes sure that resize happens after display change
                }
                // on metrics tab switch, update manual charts
                if (tabId === "metrics") {
                    updateManualCharts();
                }
            });
        });
        
        // manual metrics tab

        /* 
        > gets data from mnual_metrics.csv
        > expects 4 columns: Sprint,User,Metric,Rating
        > data collected from google form sent out each sprint
        > parses data into an object for easy access
        */
        
        function parseManualCsv(csv) {
            const rows = csv.trim().split('\n');
            const data = {};

            // skip header row
            for (let i = 1; i < rows.length; i++) {
                const parts = rows[i].split(',');
               
                // expecting Sprint, User, Metric , Rating
                if (parts.length < 4) continue;
                
                const sprint = parseInt(parts[0].trim());
                const user = parts[1].trim();
                const metric = parts[1].trim();
                const rating = parseFloat(parts[2].trim());
                
                // making sure data is valid
                if (isNaN(sprint) || isNaN(rating) || !metric || !user) continue;


                // creates a user or metric object if it doesn't exist to ensure rating can be assigned
                if(!data[user]){
                  data[user] = {};
                }
                if (!data[metric]) {
                    data[metric] = {};
                }
                
                data[metric][sprint] = rating;
            }
            return data;
        }

        /* 
        creates or updates a manual metric chart for the Metrics tab
        > {string} id - the canvas element ID
        > {string} label - the metric label (e.g., "Client Satisfaction")
        > {number} value - the current rating value
        > {number} max - the maximum rating value currently set to 5, update if google form is updated
        > {string} color - the color for the filled portion of the chart
        */
        function createOrUpdateManualChart(id, label, value, max, color) {
            const ctx = document.getElementById(id).getContext('2d');

            // if there was already an instance ofthe manual chart delete it before creating updated one to prevent memory leaks
            if (manualChartInstances[id]) {
                manualChartInstances[id].destroy();
            }

            // update chart title with current value/max
            document.getElementById(id + "Title").innerText = `${label} (${value}/${max})`;

            manualChartInstances[id] = new Chart(ctx, {
                type: 'doughnut', 
                data: {
                    labels: [label, 'Remaining'],
                    datasets: [{
                        label: 'Rating (Max ' + max + ')',
                        data: [value, max - value], // data for filled and unfilled portions
                        backgroundColor: [color, '#dddddd'], 
                        hoverOffset: 4,
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    // currently semicircle (gauge)
                    circumference: 180, // if we do 10 as max instead of 5 should change to 360
                    rotation: 270,
                    cutout: '70%', // thicknes of doughnut
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: false 
                        },
                        tooltip: {
                            callbacks: {
                                // custome tooltip to create hover feature that displays metric information and value
                                label: function(tooltipItem) {
                                    return tooltipItem.label === label ? `${label}: ${tooltipItem.formattedValue}` : '';
                                }
                            }
                        }
                    }
                }
            });
        }

        /* async functions used so that we can await fetching and parsing of manual_metrics.csv
        ️ updates all manual metric charts based on selected user and sprint
        */

        async function updateManualCharts() {
            
            // if data is not already in memory, load it 
            if (Object.keys(parsedManualMetricsData).length === 0) {
                try{
                  const response = await fetch('manual_metrics.csv');
                  if(!response.ok){
                    // if we are unable to fetch file, throw error to be caught
                    throw new Error('Network response faulty');
                  }
                  const csvData = await response.text();
                  parsedManualMetricsData = parseManualCsv(csvData); // parse and store data in memory
                } catch(error){
                  console.error('Error fetching or parsing manual metrics CSV:', error);
                  document.getElementById('metrics').innerHTML = `<h2>Error loading manual_metrics.csv</h2><p>${error.message}</p>`;
                  return;
                }
              }
            // get selected sprint and user
            const sprintIndex = parseInt(document.getElementById("metricsSprintSelect").value);
            const sprint = sprintIndex + 1; // sprints are 1-indexed in manual_metrics.csv
            const user = document.getElementById("metricsUserSelect").value; // get selected user
            
            // configurations for each metric chart to be sent to createOrUpdateManualChart
            const metricConfigs = [
                { id: "clientSatisfaction", label: "Client Satisfaction", color: "mediumorchid", key: "client satisfaction" },
                { id: "teamSatisfaction", label: "Team Satisfaction", color: "lightskyblue", key: "team satisfaction" },
                { id: "collaboration", label: "Collaboration", color: "lightgreen", key: "collaboration" },
                { id: "sprintConfidence", label: "Sprint Confidence", color: "lightpink", key: "sprint confidence" },
                { id: "goalAchievement", label: "Goal Achievement", color: "moccasin", key: "goal achievement" }
            ];

            const maxRating = 5.0; //change if we set max rating as 10 rather than 5
            
            // create/update each manual metric chart
            metricConfigs.forEach(config => {

                // access specified user and metric data for selected sprint, default to 0 if not found
                let value = parsedManualMetricsData[user]?.[config.key]?.[sprint] ?? 0;
                // make sure max rating is not exceeded
                value = Math.min(value, maxRating); 

                createOrUpdateManualChart(
                    config.id,
                    config.label,
                    value,
                    maxRating,
                    config.color
                );
            });
        }

        // team tab

        /*
        > updates the metrics display section in the Team tab
        > shows ONLY individual user metrics with progress bars compared to team totals
        */
        function updateMetricsDisplay() {
            const user = document.getElementById("teamUserSelect").value;
            const sprintIndex = parseInt(document.getElementById("teamSprintSelect").value);
            const display = document.getElementById("metricsDisplay");

            // make sure a specific user is selected
            if (!metricsData || Object.keys(metricsData).length === 0) {
                display.innerHTML = "<h3>No metrics data loaded. Please select a repository.</h3>";
                return;
            }

            if (user == 'tm') {
                display.innerHTML = "<h3>Please select an individual user to view metrics.</h3>";
                return;
            }
            // sprint dates for display purposes
            const sprintDates = [
                "Sep 8 - Sep 22", "Sep 22 - Oct 6", "Oct 6 - Oct 20",
                "Oct 20 - Nov 3", "Nov 3 - Nov 17", "Nov 17 - Nov 31"
            ];


            const selectedUserText = document.getElementById("teamUserSelect").options[document.getElementById("teamUserSelect").selectedIndex].text;
            // get org and repo names from metricsData.json
            const orgName = metricsData.org || "unknownOrg";
            const repoName = metricsData.repo || "unknownRepo";
            let html = `<h3>Metrics for ${selectedUserText} - Sprint ${sprintIndex + 1} (${sprintDates[sprintIndex]}) | Repo: ${repoName} | Org: ${orgName}</h3><ul>`;
            // list of metrics to display
            const autoMetrics = [
                "leadTime", "cycleTime", "deliveryMetrics",
                "commitFrequency", "issuesOpened", "issuesClosed",
                "issueTimeResolved", "prTimeMerged", "wip"
            ];

            autoMetrics.forEach(key => {
                // determine the correct key based on selected user
                const userMetricKey = Object.keys(metricsData).find(k => k.startsWith(key) && k.includes(user));
                const value = userMetricKey ? metricsData[userMetricKey][sprintIndex] : undefined;

                if (value === undefined) {
                    html += `<li><strong>${key}:</strong> N/A</li>`;
                    return;
                }

                // calculate team total across all users for this metric
                const teamTotal = Object.keys(metricsData)
                    .filter(k => k.startsWith(key))
                    .reduce((sum, k) => {
                        const val = metricsData[k][sprintIndex];
                        return sum + (typeof val === "number" ? val : 0);
                    }, 0);

                let pct = teamTotal > 0 ? (value / teamTotal) * 100 : 0;

                const description = metricDescriptions[key] || "No description available.";

                const userColor = "#eabda8";
                const teamColor = "#cccccc";

                // add metric with progress bar to html
                html += `
            <li>
              <strong title="${description}" style="cursor: help;">${key}:</strong> ${value}
              <div style="width: 100%; max-width: 300px; height: 15px; border-radius: 8px; overflow: hidden; display: flex; margin-top: 5px;">
                <div style="width: ${pct}%; background-color: ${userColor};"></div>
                <div style="width: ${100 - pct}%; background-color: ${teamColor};"></div>
              </div>
              <small>${pct.toFixed(1)}% of team total</small>
            </li>
          `;

            });

            html += "</ul>";
            display.innerHTML = html;
        }

        /* creates or updates the time-based metrics chart in the Team tab
        ️> {array} chartLabels - labels for the metric names (x-axis)
        ️> {string} datasetLabels - label for the dataset (e.g "Team Lead - Sprint 1")
        ️> {array} dataValues - data values for the bar chart (y-axis)
        */
        function createOrUpdateTimeChart(chartLabels, datasetLabels, dataValues) {
            
          // if chart already exists, destroy it before creating updated one
          if (timeChartInstance) {
                timeChartInstance.destroy();
            }
            const ctx = document.getElementById("timeBasedMetrics").getContext("2d");
            timeChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: datasetLabels,
                        data: dataValues,
                        backgroundColor: 'rgba(85, 12, 24, 0.7)',
                        borderColor: 'rgba(85, 12, 24, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    resizeDelay: 50,
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: 'black',
                                font: {
                                    size: 15
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time-Based Metrics'
                            }
                        },

                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: 'black',
                                font: {
                                    size: 15
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time (Days)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: true,
                            callbacks: {
                              // hover descriptions for metrics, currently not completely working
                                afterBody: function(tooltipItem) {
                                    const timeMetricKeyMap = {
                                        "Lead Time": "leadTime",
                                        "Cycle Time": "cycleTime",
                                        "Delivery Metrics": "deliveryMetrics",
                                        "Issue Time Resolved": "issueTimeResolved",
                                        "PR Time Merged": "prTimeMerged"
                                    };
                                    const dataIndex = tooltipItem[0].dataIndex;
                                    const chart = tooltipItem[0].chart;
                                    const label = chart.data.labels[dataIndex];
                                    const key = timeMetricKeyMap[label];
                                    const description = metricDescriptions[key] || 'No description';
                                    return [description];


                                }
                            }
                        }
                    }
                }
            });
        }
        /* creates or updates volume-based metrics bar chart
        > {array} chartLabels - labels for the metric names (x-axis)
        ️> {string} datasetLabels - label for the dataset (e.g "Team Lead - Sprint 1")
        ️> {array} dataValues - data values for the bar chart (y-axis)
        */
        function createOrUpdateVolumeChart(chartLabels, datasetLabels, dataValues) {
          
          // if chart already exists, destroy it before creating updated one
          if (volumeChartInstance) {
                volumeChartInstance.destroy();
            }
            const ctx = document.getElementById("volumeBasedMetrics").getContext("2d");
            volumeChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: datasetLabels,
                        data: dataValues,
                        backgroundColor: 'rgba(85, 12, 24, 0.7)',
                        borderColor: 'rgba(85, 12, 24, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    resizeDelay: 50,
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: 'black',
                                font: {
                                    size: 15
                                }
                            },
                            title: {
                                display: true,
                                text: 'Volume-Based Metrics'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: 'black',
                                font: {
                                    size: 15
                                }
                            },
                            title: {
                                display: true,
                                text: 'Count'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: true,
                            callbacks: {
                              // hover feature for metric information, currently not completely functional
                                afterBody: function(tooltipItem) {
                                    const volumeMetricKeyMap = {
                                        "Delivery Metrics": "deliveryMetrics",
                                        "Commit Frequency": "commitFrequency",
                                        "Issues Opened": "issuesOpened",
                                        "Issues Closed": "issuesClosed",
                                        "WIP": "wip"
                                    };
                                    const dataIndex = tooltipItem[0].dataIndex;
                                    const chart = tooltipItem[0].chart;
                                    const label = chart.data.labels[dataIndex];
                                    const key = volumeMetricKeyMap[label];
                                    const description = metricDescriptions[key] || 'No description';
                                    return [description];
                                }
                            }
                        }
                    }
                }
            });
        }
        /* team tab updator
        > gather information based on filter and calls updators
        */
        function updateTeamTab() {
          if (!metricsData || Object.keys(metricsData).length === 0) {
              console.warn("⚠️ No metrics data loaded yet.");
              return;
          }
          
          updateMetricsDisplay();

          // what sprint and what user (or team), later will probably add repo as selection (so user would select repo then select the desired user)
          const user = document.getElementById("teamUserSelect").value;
          const sprintIndex = parseInt(document.getElementById("teamSprintSelect").value);
          const selectedUserText = document.getElementById("teamUserSelect").options[document.getElementById("teamUserSelect").selectedIndex].text;

          // what metrics are going on each chart
          const timeBasedLabels = [
              "Lead Time", "Cycle Time", "Delivery Metrics",
              "Issue Time Resolved", "PR Time Merged"
          ];
          const metricKeys = [
              "leadTime", "cycleTime", "deliveryMetrics",
              "issueTimeResolved", "prTimeMerged"
          ];
          const volumeKeys = [
              "deliveryMetrics", "commitFrequency", "issuesOpened", "issuesClosed", "wip"            ];
            const volumeBasedLabels = [
                "Delivery Metrics", "Commit Frequency", "Issues Opened", "Issues Closed", "WIP"
          ];

          let timeBasedData = [];
          let volumeBasedData = [];
          let chartLabel = '';

          // if selected user is total team calculate total
          if (user == 'tm') {
              chartLabel = `Overall Team Average - Sprint ${sprintIndex + 1}`;
              const userKeys = Object.keys(metricsData).filter(k => k.includes("_"));
              const users = [...new Set(userKeys.map(k => k.split("_")[1]))];
              timeBasedData = metricKeys.map(key => {
                  let total = 0;
                  let count = 0;
                  Object.keys(metricsData).forEach(k => {
                      if (k.startsWith(key)) {
                          const val = metricsData[k][sprintIndex];
                          if (!isNaN(val)) {
                              total += val;
                              count++;
                          }
                      }
                  });
                  return count > 0 ? (total / count) : 0;
              });
              volumeBasedData = volumeKeys.map(key => {
                  let total = 0;
                  Object.keys(metricsData).forEach(k => {
                      if (k.startsWith(key)) {
                          const val = metricsData[k][sprintIndex];
                          if (!isNaN(val)) total += val;
                      }
                  });
                  return total;
              });
          } else { // if not the team then get the specified user
              chartLabel = `${selectedUserText} - Sprint ${sprintIndex + 1}`;
              timeBasedData = metricKeys.map(key => {
                  const metricKey = Object.keys(metricsData).find(k => k.startsWith(key) && k.includes(user));
                  return metricKey ? metricsData[metricKey][sprintIndex] : 0;
              });
              volumeBasedData = volumeKeys.map(key => {
                  const metricKey = Object.keys(metricsData).find(k => k.startsWith(key) && k.includes(user));
                  return metricKey ? metricsData[metricKey][sprintIndex] : 0;
              });
          }
          // create the charts with the gathered data
          createOrUpdateTimeChart(timeBasedLabels, chartLabel, timeBasedData);
          createOrUpdateVolumeChart(volumeBasedLabels, chartLabel, volumeBasedData);
        }

    /* =====================
       Repository & User Loader (Team)
       Reads oss_slu_repos.json and populates Team dropdowns and loads corresponding metrics_<repo>.json
       ===================== */
    async function loadRepositoriesAndUsers() {
        try {
            const response = await fetch('oss_slu_repos.json');
            if (!response.ok) {
                throw new Error(`Failed to load oss_slu_repos.json: ${response.status}`);
            }

            const reposData = await response.json();
            const repoSelect = document.getElementById("teamRepoSelect");
            const userSelect = document.getElementById("teamUserSelect");

            // Clear old options
            repoSelect.innerHTML = '<option value="" disabled selected>Select Repository</option>';
            userSelect.innerHTML = '<option value="" disabled selected>Select User</option>';

            // Populate repositories
            Object.keys(reposData).forEach(repo => {
                const opt = document.createElement("option");
                opt.value = repo;
                opt.textContent = repo;
                repoSelect.appendChild(opt);
            });

            // Update users when a repository is selected
            repoSelect.addEventListener("change", async () => {
                const selectedRepo = repoSelect.value;
                const repoInfo = reposData[selectedRepo];

                // Load metrics for this repo into metricsData by fetching metrics_<repo>.json
                await fetchMetricsForRepo(selectedRepo);

                userSelect.innerHTML = '<option value="tm" selected>Overall Team</option>';

                if (repoInfo) {
                    // Add contributors
                    repoInfo.contributors.forEach(user => {
                        const opt = document.createElement("option");
                        opt.value = user;
                        opt.textContent = user;
                        userSelect.appendChild(opt);
                    });

                    // Add tech leads (with _tl suffix)
                    repoInfo.tech_leads.forEach(user => {
                        const opt = document.createElement("option");
                        opt.value = user;
                        opt.textContent = user.replace("_tl", " (Tech Lead)");
                        userSelect.appendChild(opt);
                    });
                }

                // Trigger update after user list refresh
                updateTeamTab();
            });

            // If there's at least one repo, select the first one automatically
            const repoKeys = Object.keys(reposData);
            if (repoKeys.length > 0) {
                repoSelect.value = repoKeys[0];
                // trigger change to populate users and load metrics
                const event = new Event('change');
                repoSelect.dispatchEvent(event);
            }

            // When user or sprint changes, update chart
            userSelect.addEventListener("change", updateTeamTab);
            document.getElementById("teamSprintSelect").addEventListener("change", updateTeamTab);

            console.log("Loaded repositories and users from oss_slu_repos.json (Team)");
        } catch (error) {
            console.error("Error loading repositories (Team):", error);
        }
    }

    /* =====================
       Repository & User Loader (Metrics Tab)
       Reads oss_slu_repos.json and populates Metrics dropdowns and loads corresponding metrics_<repo>.json
       ===================== */
    async function loadRepositoriesAndUsersForMetrics() {
        try {
            const response = await fetch('oss_slu_repos.json');
            if (!response.ok) {
                throw new Error(`Failed to load oss_slu_repos.json: ${response.status}`);
            }

            const reposData = await response.json();
            const repoSelect = document.getElementById("metricsRepoSelect");
            const userSelect = document.getElementById("metricsUserSelect");

            // Clear old options
            repoSelect.innerHTML = '<option value="" disabled selected>Select Repository</option>';
            userSelect.innerHTML = '<option value="" disabled selected>Select User</option>';

            // Populate repositories
            Object.keys(reposData).forEach(repo => {
                const opt = document.createElement("option");
                opt.value = repo;
                opt.textContent = repo;
                repoSelect.appendChild(opt);
            });

            // Update users when a repository is selected
            repoSelect.addEventListener("change", async () => {
                const selectedRepo = repoSelect.value;
                const repoInfo = reposData[selectedRepo];

                // Load metrics for this repo into metricsData by fetching metrics_<repo>.json
                await fetchMetricsForRepo(selectedRepo);

                userSelect.innerHTML = '<option value="tm" selected>Overall Team</option>';

                if (repoInfo) {
                    // Add contributors
                    repoInfo.contributors.forEach(user => {
                        const opt = document.createElement("option");
                        opt.value = user;
                        opt.textContent = user;
                        userSelect.appendChild(opt);
                    });

                    // Add tech leads (with _tl suffix)
                    repoInfo.tech_leads.forEach(user => {
                        const opt = document.createElement("option");
                        opt.value = user;
                        opt.textContent = user.replace("_tl", " (Tech Lead)");
                        userSelect.appendChild(opt);
                    });
                }

                // Trigger update after user list refresh
                updateManualCharts();
            });

            // If there's at least one repo, select the first one automatically
            const repoKeys = Object.keys(reposData);
            if (repoKeys.length > 0) {
                repoSelect.value = repoKeys[0];
                // trigger change to populate users and load metrics
                const event = new Event('change');
                repoSelect.dispatchEvent(event);
            }

            // When user or sprint changes, update manual charts
            userSelect.addEventListener("change", updateManualCharts);
            document.getElementById("metricsSprintSelect").addEventListener("change", updateManualCharts);

            console.log("✅ Loaded repositories and users from oss_slu_repos.json (Metrics)");
        } catch (error) {
            console.error("❌ Error loading repositories (Metrics):", error);
        }
    }

    /* Fetch metrics_<repo>.json and store into metricsData, then update tabs */
    async function fetchMetricsForRepo(repoName) {
        if (!repoName) return;
        const filename = `metrics_${repoName}.json`;
        try {
            const resp = await fetch(filename);
            if (!resp.ok) {
                console.warn(`Could not load ${filename} (status ${resp.status}), leaving metricsData as-is.`);
                return;
            }
            const data = await resp.json();
            // set metricsData to loaded file
            metricsData = data;
            console.log(`✅ Loaded metrics for repo: ${repoName}`);
            // update displays
            updateTeamTab();
            updateManualCharts();
        } catch (err) {
            console.error(`Error fetching ${filename}:`, err);
        }
    }

  /* initialized dashboard, runs when page loads */
  async function initializeDashboard() {
      // check for metrics.json
      try {
          // load repositories/users before updating tabs/charts
          await loadRepositoriesAndUsers();
          await loadRepositoriesAndUsersForMetrics();

          // update tabs/charts
          const teamRepoSelect = document.getElementById("teamRepoSelect");
          const firstRepo = teamRepoSelect.value;
          if (firstRepo) {
              await fetchMetricsForRepo(firstRepo);
          }

          // creates event listeners to metrics tab filters
          document.getElementById("teamUserSelect").addEventListener("change", updateTeamTab);
          document.getElementById("teamSprintSelect").addEventListener("change", updateTeamTab);
          document.getElementById("metricsUserSelect").addEventListener("change", updateManualCharts);
          document.getElementById("metricsSprintSelect").addEventListener("change", updateManualCharts);

          // creates listen to resize chart on fullscreen (had a rendering bug and used this as a solution)
          document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
              setTimeout(() => {
                if (timeChartInstance) {
                    timeChartInstance.resize();
                }
                if (volumeChartInstance) {
                    volumeChartInstance.resize();
                }
                Object.values(manualChartInstances).forEach(chart => chart.resize());
              }, 200);
            }
          });
      } catch (error) {
         console.error('Failed to load initial metrics.json', error);
        document.querySelector('.content').innerHTML = `<h1>Fatal Error: Could not load metrics.json</h1><p>Please ensure the file is in the same directory and you are running a local server.</p><p>${error.message}</p>`;
      }
  }
  
async function loadHomeDashboard() {
    console.log("Loading OSS-SLU dashboard…");

    let reposData;
    try {
        const resp = await fetch("oss_slu_repos.json");
        if (!resp.ok) throw new Error("Failed to load oss_slu_repos.json");
        reposData = await resp.json();
    } catch (err) {
        console.error("Failed to load repos:", err);
        return;
    }

    const repoNames = Object.keys(reposData);

    let totalCommitsNum = 0;
    let allLeadTimes = [];
    let allCycleTimes = [];
    let allContributors = new Set();
    const repoActivityMap = {};
    const allMetricsByRepo = {};  // ← THIS IS THE KEY

    const repoActivityContainer = document.getElementById("repoActivity");
    repoActivityContainer.innerHTML = "";

    const tbody = document.querySelector("#contributorsTableHome tbody");
    tbody.innerHTML = "";

    // Process each repo independently
    for (const repo of repoNames) {
        const metricsFile = `metrics_${repo}.json`;
        let metrics = {};

        try {
            const r = await fetch(metricsFile);
            if (!r.ok) {
                console.warn(`Skipping ${metricsFile} — not found or error ${r.status}`);
                continue;
            }
            metrics = await r.json();
        } catch (err) {
            console.warn(`Failed to load ${metricsFile}`, err);
            continue;
        }

        // Store for later use in contributor table
        allMetricsByRepo[repo] = metrics;

        // === Collect lead/cycle times ===
        Object.keys(metrics).forEach(key => {
            if (key.startsWith("leadTime") && Array.isArray(metrics[key])) {
                allLeadTimes.push(...metrics[key].filter(v => typeof v === "number" && v !== null));
            }
            if (key.startsWith("cycleTime") && Array.isArray(metrics[key])) {
                allCycleTimes.push(...metrics[key].filter(v => typeof v === "number" && v !== null));
            }
        });

        // === Collect contributors ===
        if (reposData[repo]?.contributors) {
            reposData[repo].contributors.forEach(c => allContributors.add(c));
        }
        if (reposData[repo]?.tech_leads) {
            reposData[repo].tech_leads.forEach(tl => allContributors.add(tl));
        }

        // === Count commits for this repo ===
        let repoTotalCommits = 0;
        const commitKeys = Object.keys(metrics).filter(k => k.startsWith("commitFrequency-"));
        commitKeys.forEach(key => {
            const arr = metrics[key];
            if (Array.isArray(arr)) {
                arr.forEach(num => {
                    if (typeof num === "number") {
                        repoTotalCommits += num;
                        totalCommitsNum += num;  // NOW ADDS FROM EVERY REPO
                    }
                });
            }
        });
        repoActivityMap[repo] = repoTotalCommits;
    }

    // === Build contributor table from ALL repos ===
    tbody.innerHTML = "";
    allContributors.forEach(user => {
        const cleanName = user.replace("_tl", "");
        const isTL = user.endsWith("_tl");
        const prefix = isTL ? "tl-" : "1-";

        let totalCommits = 0;
        let totalPRsMerged = 0;
        let totalIssuesOpened = 0;

        Object.values(allMetricsByRepo).forEach(metrics => {
            const commitKey = `commitFrequency-${prefix}${cleanName}`;
            const cycleKey = `cycleTime-${prefix}${cleanName}`;
            const issuesKey = `issuesOpened-${prefix}${cleanName}`;

            if (metrics[commitKey]) {
                totalCommits += metrics[commitKey].reduce((a, b) => a + (b || 0), 0);
            }
            if (metrics[cycleKey]) {
                totalPRsMerged += metrics[cycleKey].filter(v => v !== null).length;
            }
            if (metrics[issuesKey]) {
                totalIssuesOpened += metrics[issuesKey].reduce((a, b) => a + (b || 0), 0);
            }
        });

        tbody.innerHTML += `
            <tr>
                <td>${cleanName}${isTL ? " (Tech Lead)" : ""}</td>
                <td>${totalCommits}</td>
                <td>${totalPRsMerged}</td>
                <td>${totalIssuesOpened}</td>
            </tr>`;
    });

    // === Update summary cards ===
    document.getElementById("reposCount").innerText = repoNames.length;
    document.getElementById("commitsCount").innerText = totalCommitsNum;
    document.getElementById("contributorsCount").innerText = allContributors.size;

    const avgLead = allLeadTimes.length > 0
        ? (allLeadTimes.reduce((a, b) => a + b, 0) / allLeadTimes.length).toFixed(2)
        : "0.00";
    const avgCycle = allCycleTimes.length > 0
        ? (allCycleTimes.reduce((a, b) => a + b, 0) / allCycleTimes.length).toFixed(2)
        : "0.00";

    document.getElementById("leadTimeHome").innerText = avgLead + " days";
    document.getElementById("cycleTimeHome").innerText = avgCycle + " days";

    // === Repo activity bars ===
    const maxActivity = Math.max(...Object.values(repoActivityMap), 1);
    repoActivityContainer.innerHTML = "";
    for (const repo of repoNames) {
        const commits = repoActivityMap[repo] || 0;
        const percent = maxActivity > 0 ? (commits / maxActivity) * 100 : 0;

        repoActivityContainer.innerHTML += `
            <div style="margin-bottom:10px;">
                <div style="display:flex;justify-content:space-between;font-size:14px;">
                    <span>${repo}</span>
                    <span>${percent.toFixed(0)}%</span>
                </div>
                <div class="progress">
                    <div class="bar" style="width:${percent}%"></div>
                </div>
                <small>${commits} commits</small>
            </div>
        `;
    }

    renderHomeCharts();
}
function renderHomeCharts() {
    new Chart(document.getElementById("velocityChartHome"), {
        type: "line",
        data: {
            labels: ["W1","W2","W3","W4"],
            datasets: [
                { label: "Velocity (Aggregated)", data: [12,20,14,35], borderColor: "#550C18", fill: false }
            ]
        }
    });

    new Chart(document.getElementById("leadCycleChartHome"), {
        type: "line",
        data: {
            labels: ["W1","W2","W3","W4"],
            datasets: [
                { label: "Lead Time", data: [5,4,6,5], borderColor: "#933", fill: false },
                { label: "Cycle Time", data: [3,3,4,3], borderColor: "#550C18", fill: false }
            ]
        }
    });
}

window.addEventListener("load", loadHomeDashboard);
// start the dashboard yipppeeee
  initializeDashboard();

    </script>
</body>

</html>
